\subsection{Syllabus}

The course deals with the basics of functional programming and the verification of functional programs.
Most parts of the course could be done using any functional language.
We chose Haskell because of its simple syntax, large user community, and good testing facilities (in particular QuickCheck).

The syllabus of the course stayed close to the one presented in~\citep{next_1100}.
Notable changes include the omission of the parser case study -- parsing problems were instead introduced in homework exercises -- and the rigorous introduction of computation induction and type inference.
\kevin{Question: more detail needed?}

Concepts are introduced in self-contained small steps.
Characteristic features of functional programming languages such as
higher-order functions and algebraic data types are
only introduced midway through the course.
This makes the design of interesting practical tasks harder
but ensures that students are not overwhelmed by the diversity
of new principles that are not part of introductory imperative programming courses.
In general, the course progresses from ideas close to what is known from imperative languages (e.g.\ boolean conditions, recursion on numbers, auxiliary functions, etc.)
to simple applications of new concepts (e.g.\ recursion and induction on lists)
to generalised new concepts (e.g.\ algebraic data types and structural induction).

