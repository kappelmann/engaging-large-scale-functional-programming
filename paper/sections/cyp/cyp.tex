\section{Check Your Proof by Example}\label{sec:cyp}
In addition to functional programming, the course we taught is also concerned with verification of programs; more specifically functional programs.
Even if we only consider a small total subset of Haskell, equational reasoning together with induction (and case analysis) is already sufficient to prove interesting properties.
Since fast and loose reasoning is morally correct~\cite{fast_and_loose}, valid properties in this sub-language are also valid for Haskell.
Simple inductive proofs of course lend themselves well to be automatically checked and, as announced by \cite{next_1100}, a tool called ``Check Your Proof'' (CYP for short) was developed at our lab by Durner and Noschinski\footnote{\url{https://github.com/noschinl/cyp}}.
The first example of an inductive proof in the lecture is the associativity of append on lists.
Transferring this example to CYP requires us to define the data type of lists.
We use \lstinline![]! as the constructor of the empty list and the infix operator \lstinline!:! like in Haskell.
\begin{lstlisting}
data List a = [] | a : List a
\end{lstlisting}
Now we can define append as the customary infix operator \lstinline!++! and state the goal \lstinline!xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs! where all variables are implicitly universally quantified.
\begin{lstlisting}
[] ++ ys = ys
(x : xs) ++ ys = x : (xs ++ ys)
goal xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs
\end{lstlisting}
The listings above make up the background theory for this particular proof.
These definitions are meant to be provided to the students by the instructors and are not to be modified.
The students then supply the proof in a separate file.
In our case, we proceed to prove the statement by structural induction on \lstinline!xs!.
\begin{lstlisting}
Lemma: xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs
Proof by induction on List xs
  Case []
    To show: [] ++ (ys ++ zs) .=. ([] ++ ys) ++ zs
    Proof
                      [] ++ (ys ++ zs)
      (by def ++) .=. ys ++ zs
      (by def ++) .=. ([] ++ ys) ++ zs
    QED
\end{lstlisting}
In the listing above, the first \lstinline!Proof! marks the beginning of an inductive proof whereas the second \lstinline!Proof!, which has no further arguments, starts an equational proof.
While CYP allows arbitrary nesting of proofs by case analysis or induction, at the innermost level it always is down to an equational proof to discharge the goal.
An equational proof is a chain of equalities that rewrite the left-hand side of the current goal to the right-hand side.
Note that in the example \lstinline!(by def ++)! refers to either one of the defining equations of \lstinline!++! so CYP will try if any of them justifies the current step.
The user has to justify each rewrite step by a corresponding equation that, when applied to the term or a subterm on the left-hand side, yields the right-hand side.

Now, consider the inductive case.
\begin{lstlisting}
  Case x : xs
    To show: (x : xs) ++ (ys ++ zs) .=. ((x : xs) ++ ys) ++ zs
    IH: xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs
    Proof
                        (x : xs) ++ (ys ++ zs)
      (by def ++)   .=. x : (xs ++ (ys ++ zs))
      (by IH)       .=. x : ((xs ++ ys) ++ zs)
      (by def ++)   .=. (x : (xs ++ ys)) ++ zs
      (by def ++)   .=. ((x : xs) ++ ys) ++ zs
    QED
QED
\end{lstlisting}
Again, CYP requires the user to be explicit: the goal in each inductive case and the induction hypotheses have to be spelled out.

The lecture then goes beyond proofs by structural induction and introduces proof by extensionality, case analysis, and computation induction, all of which CYP supports with some conditions applying as we will see shortly.
Computation induction in particular was not supported in the original version by Durner and Noschinski but was only introduced in a fork\footnote{\url{https://github.com/lukasstevens/cyp}}.
Furthermore, CYP allows proving named lemmas to modularise proofs and to prove generalised versions of the goal, which is for example necessary to show certain properties of \lstinline!fold!.

The simplicity of CYP both in its usage and its implementation brings with it some caveats:
\begin{itemize}
    \item The version of CYP that we use is untyped and thus unsound if the background theory contains multiple types as \cite{cyp_holes} demonstrate: if you have a singleton type \lstinline!data U = U! in your background theory, you can prove \lstinline!x .=. y! by case analysis.
        In an untyped environment you can then use this to prove equality between any two terms.
    \item Barring soundness issues due to a lack of types, one also needs to ensure that all function definitions are total and that their patterns do not overlap.
    \item Computation induction is only sound if there are no recursive calls in branches of an if-then-else expression.
      This is because the induction hypotheses then would need to be conditional rewrite rules which CYP does not support.
\end{itemize}
\cite{cyp_holes} discuss the inner workings of CYP in detail and develop an extension to CYP that introduces types thus solving the first issue.
In the process they also made it possible to leave holes in proofs and in expressions for the students to fill in, which makes it a more flexible tool for teaching.
Solving the latter issues would incur additional effort.
We think that CYP should be put on a stronger foundation such as higher-order logic (HOL) without compromising its simplicity from a user perspective.
One possibility would be to rewrite CYP as as a frontend to Isabelle/HOL~\cite{isabelle}.
Since HOL is a typed logic it would solve the first issue and the latter issues could be resolved using Isabelle's function package~\cite{isabelle_functions}.
A stronger foundation also allows one to more confidently develop further extensions to CYP.

Our experience with using CYP to teach inductive proofs have been very positive.
On the one hand, CYP is scalable since it has an integration with the same testing framework, Tasty\footnote{\url{https://hackage.haskell.org/package/tasty}}, that is used to mark programming exercises automatically.
This allows us to deal with programming and proof exercises in a uniform way.
On the other hand, CYP was engaging to the students as their feedback shows:
in the first iteration of the lecture, we received two positive comments and one negative comment without asking for feedback on CYP.
When asked explicitly about their thoughts on CYP the second time around, the students answered with 18 positive comments and three negative comments.
The students liked the instantaneous feedback that CYP provides, which helped them to deepen their understanding of inductive proofs at their own pace.
The main criticism of CYP was the lack of documentation.
A cheatsheet developed by a tutor was later added to the repository of CYP to improve the situation.

\lukas{Move this to exam section? Also mention that uniform structure makes it easier to grade}
In each of the exams, two exercises (out of 7 -- 9) were concerned with inductive proofs.
The first exercise was a straightforward proof by structural induction while the second exercise required more creativity, e.g.\ generalisation of the goal or a computational induction.
We did not force the students to stick to CYP's syntax in the exam but we urged them to follow a similar structure, which worked well overall.

% Teaching experiences
% \begin{itemize}
%     \item Should use non-standard data types in the exam since some students just copy the induction schema otherwise.
%     \item Student feedback mostly positive as in the other paper.
%     \item Students write well structured proofs in the exam that resemble cyp proofs.
%     \item VSCode/vim highlighting thanks to students, tutors.
%     \item Proofs can automatically be checked by the submission system.
% \end{itemize}
%
% \begin{itemize}
%   \item Why cyp? Maybe ask Lars Noschinski about cyp
%   \item \href{https://arxiv.org/pdf/2009.01326.pdf}{Other CYP Paper}. Why is this only in the pre-proceedings of WFLP 2020?
%   \item Kind of exercises throughout the course.
%   \item 2020: on two tutorial sheets (3 exercises), Tutorial 4: 1, Homework 4: 2, Tutorial 5: 2, Homework 5: 1, Tutorial 9: 1, Homework 9: 1, Tutorial 13: 1, Exam: 2(Structural, Structural + Aux Lemma)/9, Retake: 2(Structural, Computation)/7
%   \item 2019: Exam 2(Structural, Structural + Generalisation)/8, Retake: 2(Structural, Computation)/7, Tutorial 5: 2, Homework 5: 2, Tutorial 6: 2, Homework 6: 2, Tutorial 7: 1, Homework 7: 1, Tutorial 9: 1, Homework 9: 1, Tutorial 13: 1
%   \item 2019 Retake has computation induction but no CYP. Maybe compare results?
%   \item 2019 CYP Feedback: positiv 2, negativ 1
%   \item 2020 CYP Feedback: positiv 18, negativ 3 (Mainly documentation)
%   \item Uses haskell-src-exts for parsing Haskell code
% \end{itemize}
