\section{Check Your Proof by Example}
As the name ``Functional Programming and Verification'' suggests, the course is also concerned with verification of programs; more specifically functional programs.
For purely functional programs equational reasoning together with induction (and case analysis) is already sufficient to prove interesting properties.
Such simple proofs of course lend themselves well to be automatically checked and, as announced by \citet{next_1100}, a tool called ``Check Your Proof'' (CYP for short) was developed by Durner and Noschinski\footnote{\url{https://github.com/noschinl/cyp}}.
The lecture considers the associativity of append on lists as the first example of verifying functional programs.
Transferring this example to CYP requires us to define the data type of lists.
We use \lstinline![]! as the constructor of the empty list and the infix operator \lstinline!:! like in Haskell.
\begin{lstlisting}
data List a = [] | a : List a
\end{lstlisting}
Now we can define append as the customary infix operator \lstinline!++! and state the goal \lstinline!xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs! where all variables are implicitly universally quantified.
\begin{lstlisting}
[] ++ ys = ys
(x : xs) ++ ys = x : (xs ++ ys)
goal xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs
\end{lstlisting}
The listings above make up the background theory for this particular proof.
These definitions are meant to be provided to the students by the instructors and are not to be modified.
The students then supply the proof in a separate file.
In our case, we proceed to prove the statement by structural induction on \lstinline!xs!.
\begin{lstlisting}
Lemma: xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs
Proof by induction on List xs
  Case []
    To show: [] ++ (ys ++ zs) .=. ([] ++ ys) ++ zs
    Proof
                      [] ++ (ys ++ zs)
      (by def ++) .=. ys ++ zs
      (by def ++) .=. ([] ++ ys) ++ zs
    QED
\end{lstlisting}
In the listing above, the first \lstinline!Proof! marks the beginning of an inductive proof whereas the second \lstinline!Proof!, which has no further arguments, starts an equational proof.
While CYP allows arbitrary nesting of proofs by case analysis or induction, at the innermost level it always is down to an equational proof to discharge the goal.
An equational proof is a chain of equalities that rewrite the left-hand side of the current goal to the right-hand side.
Note that in the example \lstinline!(by def ++)! refers to either one of the defining equations of \lstinline!++! so CYP will try if any of them justifies the current step.
The user has to justify each rewrite step by a corresponding equation that, when applied to the term or a subterm on the left-hand side, yields the right-hand side.

Now, consider the inductive case.
\begin{lstlisting}
  Case x : xs
    To show: (x : xs) ++ (ys ++ zs) .=. ((x : xs) ++ ys) ++ zs
    IH: xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs
    Proof
                        (x : xs) ++ (ys ++ zs)
      (by def ++)   .=. x : (xs ++ (ys ++ zs))
      (by IH)       .=. x : ((xs ++ ys) ++ zs)
      (by def ++)   .=. (x : (xs ++ ys)) ++ zs
      (by def ++)   .=. ((x : xs) ++ ys) ++ zs
    QED
QED
\end{lstlisting}
Again, CYP requires the user to be explicit: the goal in each inductive case and the induction hypotheses have to be spelled out.

The lecture then goes beyond proofs by structural induction and introduces proof by extensionality, case analysis, and computation induction, all of which CYP supports with some conditions applying as we will see shortly.
Computation induction in particular was not supported in the original version by Durner and Noschinski but only introduced in a fork\footnote{\url{https://github.com/lukasstevens/cyp}}.
Furthermore, CYP allows proving named lemmas to modularise proofs and to prove generalised versions of the goal, which is for example necessary to show certain properties of \lstinline!fold!. 

The simplicity of CYP both in its usage and its implementation brings with it some caveats:
\begin{itemize}
    \item The version of CYP that we use is untyped which can cause soundness problems if the background theory contains multiple types as \citet{cyp_holes} demonstrate: if you have a singleton type \lstinline!data U = U! in your background theory, you can prove \lstinline!x .=. y! by case analysis.
        In an untyped environment you can then use this to prove the equality between any two terms.
    \item Barring soundness issues due to a lack of types, one also needs to ensure that all function definitions are total and that their patterns do not overlap.
    \item Computation induction only works for functions that don't have recursive calls
\end{itemize}

Put future improvements here.

Teaching experiences
\begin{itemize}
    \item Should use non-standard data types in the exam since some students just copy the induction schema otherwise.
    \item Student feedback mostly positive as in the other paper. 
    \item Students write well structured proofs in the exam that resemble cyp proofs.
    \item VSCode/vim highlighting thanks to students, tutors.
    \item Proofs can automatically be checked by the submission system.
\end{itemize}

\begin{itemize}
  \item Why cyp? Maybe ask Lars Noschinski about cyp
  \item \href{https://arxiv.org/pdf/2009.01326.pdf}{Other CYP Paper}. Why is this only in the pre-proceedings of WFLP 2020?
  \item Kind of exercises throughout the course.
  \item 2020: on two tutorial sheets (3 exercises), Tutorial 4: 1, Homework 4: 2, Tutorial 5: 2, Homework 5: 1, Tutorial 9: 1, Homework 9: 1, Tutorial 13: 1, Exam: 2(Structural, Structural + Aux Lemma)/9, Retake: 2(Structural, Computation)/7
  \item 2019: Exam 2(Structural, Structural + Generalisation)/8, Retake: 2(Structural, Computation)/7, Tutorial 5: 2, Homework 5: 2, Tutorial 6: 2, Homework 6: 2, Tutorial 7: 1, Homework 7: 1, Tutorial 9: 1, Homework 9: 1, Tutorial 13: 1 
  \item 2019 Retake has computation induction but no CYP. Maybe compare results?
  \item 2019 CYP Feedback: positiv 2, negativ 1 
  \item 2020 CYP Feedback: positiv 18, negativ 3 (Mainly documentation)
  \item Uses haskell-src-exts for parsing Haskell code
\end{itemize}
