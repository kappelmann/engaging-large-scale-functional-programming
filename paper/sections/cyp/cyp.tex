\section{Check Your Proof}
As the name ``Functional Programming and Verification'' suggests, the course is also concerned with verification of programs; more specifically functional programs.
For purely functional programs equational reasoning together with induction (and case analysis) is already sufficient to prove interesting properties.
Such simple proofs of course lend themselves well to be automatically checked and, as announced by \citet{next_1100}, a tool called ``Check Your Proof'' (CYP for short) was developed by Durner and Noschinski\footnote{\url{https://github.com/noschinl/cyp}}.
The lecture considers the associativity of append on lists as the first example of verifying functional programs.
Transferring this example to CYP requires us to define the data type of lists.
We use \lstinline![]! as the constructor of the empty list and the infix operator \lstinline!:! like in Haskell.
\begin{lstlisting}
data List a = [] | a : List a
\end{lstlisting}
Now we can define append as the customary infix operator \lstinline!++! and state the goal \lstinline!xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs! where all variables are implicitly universally quantified.
\begin{lstlisting}
[] ++ ys = ys
(x : xs) ++ ys = x : (xs ++ ys)
goal xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs
\end{lstlisting}
We proceed to prove the statement by structural induction on \lstinline!xs!.
\begin{lstlisting}
Lemma: xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs
Proof by induction on List xs
  Case []
    To show: [] ++ (ys ++ zs) .=. ([] ++ ys) ++ zs
    Proof
                      [] ++ (ys ++ zs)
      (by def ++) .=. ys ++ zs
      (by def ++) .=. ([] ++ ys) ++ zs
    QED
\end{lstlisting}
In the listing above, the first \lstinline!Proof! marks the beginning of an inductive \lstinline!Proof! whereas the second \lstinline!Proof!, which has no further arguments, starts an equational proof.
CYP requires the user to justify each step of the proof with a corresponding equation.
\begin{lstlisting}
  Case x : xs
    To show: (x : xs) ++ (ys ++ zs) .=. ((x : xs) ++ ys) ++ zs
    IH: xs ++ (ys ++ zs) .=. (xs ++ ys) ++ zs
    Proof
                        (x : xs) ++ (ys ++ zs)
      (by def ++)   .=. x : (xs ++ (ys ++ zs))
      (by IH)       .=. x : ((xs ++ ys) ++ zs)
      (by def ++)   .=. (x : (xs ++ ys)) ++ zs
      (by def ++)   .=. ((x : xs) ++ ys) ++ zs
    QED
QED
\end{lstlisting}
IH and To show needs to be explicitly stated.
This becomes even more important with computation induction.
Computation induction is more involved to implement and a student found a bug in the initial version.

Caveats:
It would be nice to put CYP on more principled footing such as HOL, which would allow us to check type safety (actually necessary for soundness), and also use conditional equations (needed for computation induction + if).
This would not immediately solve the problem of termination and overlapping patterns.
Isabelle auto-grading would be possible but we don't want to burden make it to easy for students.

Experiences in teaching with cyp:
\begin{itemize}
    \item Should use non-standard data types in the exam since some students just copy the induction schema otherwise.
    \item Student feedback mostly positive as in the other paper.
    \item Students write well structured proofs in the exam that resemble cyp proofs.
    \item VSCode/vim highlighting thanks to students, tutors.
    \item Proofs can automatically be checked by the submission system.
\end{itemize}

\begin{itemize}
  \item Why cyp? Maybe ask Lars Noschinski about cyp
  \item \href{https://arxiv.org/pdf/2009.01326.pdf}{Other CYP Paper}. Why is this only in the pre-proceedings of WFLP 2020?
  \item Kind of exercises throughout the course.
  \item 2020: on two tutorial sheets (3 exercises), Tutorial 4: 1, Homework 4: 2, Tutorial 5: 2, Homework 5: 1, Tutorial 9: 1, Homework 9: 1, Tutorial 13: 1, Exam: 2(Structural, Structural + Aux Lemma)/9, Retake: 2(Structural, Computation)/7
  \item 2019: Exam 2(Structural, Structural + Generalisation)/8, Retake: 2(Structural, Computation)/7, Tutorial 5: 2, Homework 5: 2, Tutorial 6: 2, Homework 6: 2, Tutorial 7: 1, Homework 7: 1, Tutorial 9: 1, Homework 9: 1, Tutorial 13: 1
  \item 2019 Retake has computation induction but no CYP. Maybe compare results?
  \item 2019 CYP Feedback: positiv 2, negativ 1
  \item 2020 CYP Feedback: positiv 18, negativ 3 (Mainly documentation)
  \item Uses haskell-src-exts for parsing Haskell code
\end{itemize}
